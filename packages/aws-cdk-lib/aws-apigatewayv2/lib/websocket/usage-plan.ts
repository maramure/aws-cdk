import { Construct } from 'constructs';
import { IWebSocketApi } from './api';
import { IApiKey } from './api-key';
import { IWebSocketStage } from './stage';
import { CfnUsagePlan, CfnUsagePlanKey } from '../../../aws-apigateway/lib';
import { validateDouble, validateInteger } from '../../../aws-apigateway/lib/util';
import { IResource, Names, Resource, Token, Lazy } from '../../../core';
import { addConstructMetadata, MethodMetadata } from '../../../core/lib/metadata-resource';
import { propertyInjectable } from '../../../core/lib/prop-injectable';
import { ThrottleSettings } from '../common';

/**
 * Time period for which quota settings apply.
 */
export enum Period {
  /**
   * The quota resets every day.
   */
  DAY = 'DAY',
  /**
   * The quota resets every week.
   */
  WEEK = 'WEEK',
  /**
   * The quota resets every month.
   */
  MONTH = 'MONTH',
}

/**
 * Specifies the maximum number of requests that clients can make to API Gateway APIs.
 */
export interface QuotaSettings {
  /**
   * The maximum number of requests that users can make within the specified time period.
   * @default none
   */
  readonly limit?: number;

  /**
   * For the initial time period, the number of requests to subtract from the specified limit.
   * @default none
   */
  readonly offset?: number;

  /**
   * The time period for which the maximum limit of requests applies.
   * @default none
   */
  readonly period?: Period;
}

/**
 * Type of Usage Plan Key. Currently the only supported type is 'ApiKey'
 */
enum UsagePlanKeyType {
  API_KEY = 'API_KEY',
}

/**
 * Represents the API stages that a usage plan applies to.
 */
export interface UsagePlanPerApiStage {

  /**
   * The WebSocket API to associate with the usage plan.
   * @default none
   */
  readonly api?: IWebSocketApi;

  /**
   *
   * [disable-awslint:ref-via-interface]
   * @default none
   */
  readonly stage?: IWebSocketStage;
}

/**
 * Properties for defining an API Gateway Usage Plan for WebSocket APIs.
 */
export interface UsagePlanProps {
  /**
   * API Stages to be associated with the usage plan.
   * @default none
   */
  readonly apiStages?: UsagePlanPerApiStage[];

  /**
   * Represents usage plan purpose.
   * @default none
   */
  readonly description?: string;

  /**
   * Number of requests clients can make in a given time period.
   * @default none
   */
  readonly quota?: QuotaSettings;

  /**
   * Overall throttle settings for the API.
   * @default none
   */
  readonly throttle?: ThrottleSettings;

  /**
   * Name for this usage plan.
   * @default none
   */
  readonly usagePlanName?: string;

  /**
   * ApiKey to be associated with the usage plan.
   * @default none
   * @deprecated use `addApiKey()`
   */
  readonly apiKey?: IApiKey;
}

/**
 * Options to the UsagePlan.addApiKey() method
 */
export interface AddApiKeyOptions {
  /**
   * Override the CloudFormation logical id of the AWS::ApiGateway::UsagePlanKey resource
   * @default - autogenerated by the CDK
   */
  readonly overrideLogicalId?: string;
}

/**
 * A UsagePlan, either managed by this CDK app, or imported.
 */

export interface IUsagePlan extends IResource {
  /**
   * Id of the usage plan
   * @attribute
   */
  readonly usagePlanId: string;

  /**
   * Adds an ApiKey.
   *
   * @param apiKey the api key to associate with this usage plan
   * @param options options that control the behaviour of this method
   */
  addApiKey(apiKey: IApiKey, options?: AddApiKeyOptions): void;

}

abstract class UsagePlanBase extends Resource implements IUsagePlan {
  /**
   * Id of the usage plan
   * @attribute
   */
  public abstract readonly usagePlanId: string;

  /**
   * Adds an ApiKey.
   *
   * @param apiKey the api key to associate with this usage plan
   * @param options options that control the behaviour of this method
   */
  public addApiKey(apiKey: IApiKey, options?: AddApiKeyOptions): void {
    let id: string;
    const prefix = 'UsagePlanKeyResource';

    id = `${prefix}:${Names.nodeUniqueId(apiKey.node)}`;

    const resource = new CfnUsagePlanKey(this, id, {
      keyId: apiKey.keyId,
      keyType: UsagePlanKeyType.API_KEY,
      usagePlanId: this.usagePlanId,
    });
    if (options?.overrideLogicalId) {
      resource.overrideLogicalId(options?.overrideLogicalId);
    }
  }
}

/**
 * A UsagePlan.
 *
 * @resource AWS::ApiGateway::UsagePlan
 */
@propertyInjectable
export class UsagePlan extends UsagePlanBase {
  /** Uniquely identifies this class. */
  public static readonly PROPERTY_INJECTION_ID: string = 'aws-cdk-lib.aws-apigatewayv2.UsagePlan';

  /**
   * Import an externally defined usage plan using its ARN.
   *
   * @param scope  the construct that will "own" the imported usage plan.
   * @param id     the id of the imported usage plan in the construct tree.
   * @param usagePlanId the id of an existing usage plan.
   */
  public static fromUsagePlanId(scope: Construct, id: string, usagePlanId: string): IUsagePlan {
    class Import extends UsagePlanBase {
      public readonly usagePlanId = usagePlanId;

      constructor() {
        super(scope, id);
      }
    }
    return new Import();
  }

  /**
   * @attribute
   */
  public readonly usagePlanId: string;

  private readonly apiStages = new Array<UsagePlanPerApiStage>();

  constructor(scope: Construct, id: string, props: UsagePlanProps = { }) {
    super(scope, id);
    // Enhanced CDK Analytics Telemetry
    addConstructMetadata(this, props);
    let resource: CfnUsagePlan;

    resource = new CfnUsagePlan(this, 'Resource', {
      apiStages: Lazy.any({ produce: () => this.renderApiStages(this.apiStages) }),
      description: props.description,
      quota: this.renderQuota(props),
      throttle: this.renderThrottle(props.throttle),
      usagePlanName: props.usagePlanName,
    });

    this.apiStages.push(...(props.apiStages || []));

    this.usagePlanId = resource.ref;

    // Add ApiKey when
    if (props.apiKey) {
      this.addApiKey(props.apiKey);
    }

    // This ensures that the stages are created before the usage plan
    if (props.apiStages) {
      for (const apiStage of props.apiStages) {
        if (apiStage.stage) {
          this.node.addDependency(apiStage.stage);
        }
        if (apiStage.api) {
          this.node.addDependency(apiStage.api);
        }
      }
    }
  }

  /**
   * Adds an apiStage.
   */
  @MethodMetadata()
  public addApiStage(apiStage: UsagePlanPerApiStage) {
    this.apiStages.push(apiStage);
  }

  private renderApiStages(apiStages: UsagePlanPerApiStage[] | undefined): CfnUsagePlan.ApiStageProperty[] | undefined {
    if (apiStages && apiStages.length > 0) {
      const stages: CfnUsagePlan.ApiStageProperty[] = [];
      apiStages.forEach((apiStage: UsagePlanPerApiStage) => {
        stages.push(this.createStage(apiStage));
      });
      return stages;
    }
    return undefined;
  }

  private createStage(apiStage: UsagePlanPerApiStage): CfnUsagePlan.ApiStageProperty {
    const stage = apiStage.stage ? apiStage.stage.stageName.toString() : undefined;
    const apiId = apiStage.stage ? apiStage.stage.api.apiId : undefined;
    return {
      apiId,
      stage,
    };
  }

  private renderQuota(props: UsagePlanProps) {
    if (props.quota === undefined) {
      return undefined;
    } else {
      const limit = props.quota ? props.quota.limit : undefined;
      validateInteger(limit, 'Throttle quota limit');
      const ret = {
        limit: limit ? limit : undefined,
        offset: props.quota ? props.quota.offset : undefined,
        period: props.quota ? props.quota.period : undefined,
      };
      return ret;
    }
  }

  private renderThrottle(props: ThrottleSettings | undefined): (CfnUsagePlan.ThrottleSettingsProperty | Token) {
    let ret: CfnUsagePlan.ThrottleSettingsProperty | Token;
    if (props !== undefined) {
      const burstLimit = props.burstLimit;
      validateInteger(burstLimit, 'Throttle burst limit');
      const rateLimit = props.rateLimit;
      validateDouble(rateLimit, 'Throttle rate limit');

      ret = {
        burstLimit: burstLimit,
        rateLimit: rateLimit,
      };
    }
    return ret!;
  }
}
